WEBVTT

1
00:00:13.100 --> 00:00:16.320
Okay. Let's put aside

2
00:00:16.320 --> 00:00:20.430
this non-computable functions
and leave it to philosophers.

3
00:00:20.430 --> 00:00:25.485
We're now going to concentrate
only on computable functions.

4
00:00:25.485 --> 00:00:31.515
It appears that these computable
functions are not all the same.

5
00:00:31.515 --> 00:00:37.845
Some of them are easier to compute
and some are harder to compute,

6
00:00:37.845 --> 00:00:42.375
and the reasons of these differences
are not exactly clear.

7
00:00:42.375 --> 00:00:46.915
Honestly, it is not clear at all.

8
00:00:46.915 --> 00:00:51.035
Imagine two very similar problems.

9
00:00:51.035 --> 00:00:57.045
Each of them takes
some graph as its input.

10
00:00:57.045 --> 00:00:58.950
So, you have some vertices,

11
00:00:58.950 --> 00:01:02.940
some edges, and a graph.

12
00:01:02.940 --> 00:01:09.000
The question for
the first problem is if there is

13
00:01:09.000 --> 00:01:15.445
an Euler's path in this graph?

14
00:01:15.445 --> 00:01:19.880
The question for the second
problem is if there is

15
00:01:19.880 --> 00:01:24.490
a Hamilton path in this graph?

16
00:01:24.490 --> 00:01:27.950
The Euler's path is
the path which visits

17
00:01:27.950 --> 00:01:31.280
every edge exactly once and

18
00:01:31.280 --> 00:01:34.250
the Hamilton path is
the path which visits

19
00:01:34.250 --> 00:01:38.705
each vertex exactly once.

20
00:01:38.705 --> 00:01:43.365
The first problem is
known to be easy.

21
00:01:43.365 --> 00:01:46.820
We have an effective algorithm
for solving it.

22
00:01:46.820 --> 00:01:50.360
The second problem is
believed to be hard.

23
00:01:50.360 --> 00:01:54.440
We don't know an effective algorithm
for solving it and there are

24
00:01:54.440 --> 00:01:55.685
reasons to believe that

25
00:01:55.685 --> 00:01:59.970
this effective algorithm
doesn't even exist.

26
00:02:00.350 --> 00:02:02.750
Now, I, again, use

27
00:02:02.750 --> 00:02:06.350
some unclear theorem and
effective for a good algorithm,

28
00:02:06.350 --> 00:02:10.084
assuming that if there are
effective or good algorithms,

29
00:02:10.084 --> 00:02:16.175
there also exist ineffective
or bad algorithms.

30
00:02:16.175 --> 00:02:17.930
Here, I allude to

31
00:02:17.930 --> 00:02:26.120
some hidden parameter which
allows me to estimate algorithms,

32
00:02:26.120 --> 00:02:28.535
and to say that some
of them are good,

33
00:02:28.535 --> 00:02:32.225
some of them are bad,
and some are worse.

34
00:02:32.225 --> 00:02:36.620
There are actually plenty of
such possible parameters,

35
00:02:36.620 --> 00:02:40.250
and here I use time
or number of steps of

36
00:02:40.250 --> 00:02:46.750
deterministic turing machine
needed to perform the computation.

37
00:02:46.750 --> 00:02:51.335
So, here for these two problems
which are quite similar,

38
00:02:51.335 --> 00:02:56.015
we have very different results
for one problem.

39
00:02:56.015 --> 00:03:03.120
We have an algorithm which
requires not much time.

40
00:03:03.120 --> 00:03:08.200
For the second problem, we don't.

41
00:03:09.010 --> 00:03:12.570
Let's consider another example.

42
00:03:12.620 --> 00:03:16.455
For example, we have two integers,

43
00:03:16.455 --> 00:03:18.255
two, maybe, natural numbers,

44
00:03:18.255 --> 00:03:28.620
a which has n digits,

45
00:03:28.620 --> 00:03:35.475
and b which also has n digits.

46
00:03:35.475 --> 00:03:39.450
Now, we're going to
add these numbers,

47
00:03:39.450 --> 00:03:45.545
a and b, using the column addition
method we learned at school.

48
00:03:45.545 --> 00:03:52.944
This method will require at most
two n of elementary additions,

49
00:03:52.944 --> 00:03:55.695
and elementary addition
is just the addition

50
00:03:55.695 --> 00:03:58.785
of one digit to another digit.

51
00:03:58.785 --> 00:04:00.960
So, we see that the complexity,

52
00:04:00.960 --> 00:04:07.695
the number of steps we need to
perform to accomplish the result,

53
00:04:07.695 --> 00:04:10.260
depends on this n,

54
00:04:10.260 --> 00:04:12.645
the number of digits.

55
00:04:12.645 --> 00:04:19.340
We can say that the complexity
of the problem is O of n. So,

56
00:04:19.340 --> 00:04:22.955
it's linear regarding the number

57
00:04:22.955 --> 00:04:27.125
of digits in the numbers
we have to add.

58
00:04:27.125 --> 00:04:31.360
Now, imagine that we have
to multiply these numbers.

59
00:04:31.360 --> 00:04:32.990
So, instead of summing them,

60
00:04:32.990 --> 00:04:36.035
we have to multiply them.

61
00:04:36.035 --> 00:04:39.920
This will require
approximately n square

62
00:04:39.920 --> 00:04:43.670
of elementary or table
multiplications which

63
00:04:43.670 --> 00:04:46.075
means that the complexity of

64
00:04:46.075 --> 00:04:52.145
the multiplication problem
is O of n squared.

65
00:04:52.145 --> 00:04:58.850
We can see now that if when n grows,

66
00:04:58.850 --> 00:05:01.255
the complexity of
multiplication grows

67
00:05:01.255 --> 00:05:06.420
faster than the
complexity of addition.

68
00:05:06.500 --> 00:05:12.755
Anyway, we don't consider
multiplication problem to be very hot.

69
00:05:12.755 --> 00:05:15.065
Actually, any infinite power

70
00:05:15.065 --> 00:05:20.530
here tells us that
the problem is not so bad.

71
00:05:20.530 --> 00:05:22.575
All the problems for which we have

72
00:05:22.575 --> 00:05:24.755
a polynomial complexity algorithm,

73
00:05:24.755 --> 00:05:28.655
we consider them to be tractable.

74
00:05:28.655 --> 00:05:34.100
All such problems form
the infinite class called b.

75
00:05:34.100 --> 00:05:39.905
So, all these problems for
which we know or for which can

76
00:05:39.905 --> 00:05:45.590
exist an algorithm with polynomial
complexity defined like this.

77
00:05:45.590 --> 00:05:49.885
A set of this class of tractable
problems which we call

78
00:05:49.885 --> 00:05:52.910
P. There is another interesting class

79
00:05:52.910 --> 00:05:55.235
of problems which is called NP.

80
00:05:55.235 --> 00:05:58.279
Here, P stands for polynomial,

81
00:05:58.279 --> 00:06:02.610
and NP for non-deterministic
polynomial.

82
00:06:02.990 --> 00:06:08.535
The problems from the class
in P are those problems or

83
00:06:08.535 --> 00:06:10.830
those functions for which we can

84
00:06:10.830 --> 00:06:14.985
easily or polynomially
check and answer.

85
00:06:14.985 --> 00:06:19.115
The ability to check
the answer is important.

86
00:06:19.115 --> 00:06:22.925
Imagine one day, one of
your friends come to you and says

87
00:06:22.925 --> 00:06:27.950
that he or she developed
a computer program,

88
00:06:27.950 --> 00:06:31.550
a chess player computer
program which cannot lose.

89
00:06:31.550 --> 00:06:36.015
Now, can you easily
check this statement?

90
00:06:36.015 --> 00:06:41.130
I believe that, no, you
cannot because, actually,

91
00:06:41.130 --> 00:06:45.165
you will have to play
all possible chess games with

92
00:06:45.165 --> 00:06:49.275
this program to understand if
it can loose or it cannot.

93
00:06:49.275 --> 00:06:51.860
Now, imagine another situation that

94
00:06:51.860 --> 00:06:54.680
this friend came to you and tells you

95
00:06:54.680 --> 00:07:03.090
that he or she found a
Hamilton path on some graph.

96
00:07:03.580 --> 00:07:08.960
Now, can you check
this statement? Yes, you can.

97
00:07:08.960 --> 00:07:13.050
You can just follow
this path provided to you by

98
00:07:13.050 --> 00:07:18.590
this friend and see if it
visits every edge exactly once.

99
00:07:18.590 --> 00:07:22.550
So, the complexity of
this check will be O of n

100
00:07:22.550 --> 00:07:27.905
where n is the number of
vertices in this graph.

101
00:07:27.905 --> 00:07:33.165
So, this statement
is easily checkable,

102
00:07:33.165 --> 00:07:39.270
and the finding of
Hamilton path in some graph is,

103
00:07:39.270 --> 00:07:41.275
thus, an NP problem,

104
00:07:41.275 --> 00:07:45.050
because maybe it's hard
to find this path,

105
00:07:45.050 --> 00:07:47.210
but if somebody finds it,

106
00:07:47.210 --> 00:07:50.000
it is easy to check if it is correct.

107
00:07:50.000 --> 00:07:57.630
Out of those that P
belongs to NP, because,

108
00:07:57.630 --> 00:07:59.050
for any problem from P,

109
00:07:59.050 --> 00:08:01.040
we can easily check the answer just

110
00:08:01.040 --> 00:08:05.225
by solving this problem
with polynomial algorithm.

111
00:08:05.225 --> 00:08:07.969
But the stronger assertion,

112
00:08:07.969 --> 00:08:11.960
if P is less than NP,

113
00:08:11.960 --> 00:08:14.650
is one of the most famous,

114
00:08:14.650 --> 00:08:20.945
most important unproven theorems
in modern complexity theory.

115
00:08:20.945 --> 00:08:25.795
Because this theorem is not proven,

116
00:08:25.795 --> 00:08:30.530
we still have to consider
these two options on the slide here,

117
00:08:30.530 --> 00:08:34.070
if P is not equal to NP,

118
00:08:34.070 --> 00:08:38.560
here, and if P equals to NP.

119
00:08:38.560 --> 00:08:45.580
So, you see class P here, class NP.

120
00:08:47.570 --> 00:08:52.475
Nowadays, it is believed that
there are problems which

121
00:08:52.475 --> 00:08:57.920
belong to NP but do not belong to P,

122
00:08:57.920 --> 00:09:00.095
though we cannot prove it.

123
00:09:00.095 --> 00:09:05.875
One of such important problem
is factoring problem.

124
00:09:05.875 --> 00:09:13.590
Imagine that you have found
two different big prime numbers,

125
00:09:13.590 --> 00:09:20.775
p and q, each like 10,000 digits.

126
00:09:20.775 --> 00:09:26.205
You multiply them, and
you get the product.

127
00:09:26.205 --> 00:09:30.985
Both these tasks are like
finding big primes and

128
00:09:30.985 --> 00:09:36.420
multiplicating them is
feasible for modern computers.

129
00:09:36.690 --> 00:09:40.735
Then, you give me this number n,

130
00:09:40.735 --> 00:09:45.140
and you ask me if I can find
these original factors.

131
00:09:45.140 --> 00:09:49.670
We both know that there is
only one set of such factors.

132
00:09:49.670 --> 00:09:53.720
So, theoretically, I can
do this, but, in practice,

133
00:09:53.720 --> 00:09:59.750
I cannot because for
all algorithms to solve this task,

134
00:09:59.750 --> 00:10:01.145
we know by now,

135
00:10:01.145 --> 00:10:05.405
they all will require too many steps,

136
00:10:05.405 --> 00:10:08.240
and with the reasonable assumptions

137
00:10:08.240 --> 00:10:10.970
about the growth of
our computing power,

138
00:10:10.970 --> 00:10:13.055
I will not finish the execution

139
00:10:13.055 --> 00:10:15.155
of these algorithms until my death,

140
00:10:15.155 --> 00:10:18.520
or even until
the Solar System's death.

141
00:10:18.520 --> 00:10:23.125
As I said, they require
too many steps.

142
00:10:23.125 --> 00:10:28.685
So, this problem of factor
is theoretically solvable.

143
00:10:28.685 --> 00:10:30.380
It is computable.

144
00:10:30.380 --> 00:10:33.110
But it is intractable because,

145
00:10:33.110 --> 00:10:39.700
in practice, we can not
solve this problem.

146
00:10:39.830 --> 00:10:42.925
To finish here on a brighter note,

147
00:10:42.925 --> 00:10:50.410
in 1994, an American mathematician,

148
00:10:50.410 --> 00:10:58.090
Peter Shor, designed
a quantum algorithm

149
00:10:58.090 --> 00:11:03.220
which solves this factoring problem
in polynomial time.

150
00:11:03.220 --> 00:11:08.200
So, now quantum computers can

151
00:11:08.200 --> 00:11:15.115
solve problems that are intractable
for classical computers.

152
00:11:15.115 --> 00:11:19.460
All of them? Well, probably not.

153
00:11:19.460 --> 00:11:21.200
Here on these diagrams,

154
00:11:21.200 --> 00:11:26.825
you see another interesting class
which is called NP-Hard.

155
00:11:26.825 --> 00:11:30.695
These are the problems for
which any problem from

156
00:11:30.695 --> 00:11:34.630
NP are polynomially
reducible which means that,

157
00:11:34.630 --> 00:11:38.630
if you have some magic
black box which solve

158
00:11:38.630 --> 00:11:43.685
some problems from here effectively,

159
00:11:43.685 --> 00:11:46.115
with this magic box,

160
00:11:46.115 --> 00:11:53.565
we can polynomially solve
any problem from here,

161
00:11:53.565 --> 00:11:55.230
from the class NP.

162
00:11:55.230 --> 00:12:03.030
In 1972, an American-Canadian
mathematician,

163
00:12:03.030 --> 00:12:08.015
Stephen Cook, proved
that the intersection of

164
00:12:08.015 --> 00:12:14.995
this class of NP hard problems
with the class NP is not empty.

165
00:12:14.995 --> 00:12:18.750
Now, this intersection is

166
00:12:18.750 --> 00:12:26.130
called NP-complete or the class
of NP-Complete problems or NPC,

167
00:12:26.130 --> 00:12:31.040
which are the most difficult
problems in the class NP.

168
00:12:31.040 --> 00:12:36.680
So, if you find an effective
solution for some problem from here,

169
00:12:36.680 --> 00:12:39.200
we can effectively solve any problem

170
00:12:39.200 --> 00:12:43.165
from the class NP with this solution.

171
00:12:43.165 --> 00:12:46.220
Unfortunately for factoring problem,

172
00:12:46.220 --> 00:12:51.110
it is not yet proved that it
belongs to NP-Complete problems,

173
00:12:51.110 --> 00:12:54.430
and, actually, it is
believed that it does not.

174
00:12:54.430 --> 00:12:57.490
So, it's somewhere here.

175
00:12:57.490 --> 00:13:00.720
But for all these problems,

176
00:13:00.720 --> 00:13:03.345
for NP-Complete problems, in general,

177
00:13:03.345 --> 00:13:07.880
we have a better general solution

178
00:13:07.880 --> 00:13:13.610
for quantum computers than
we have for classical ones.

179
00:13:13.610 --> 00:13:17.120
For these problems from here,

180
00:13:17.120 --> 00:13:22.665
we still cannot say
anything reassuring

181
00:13:22.665 --> 00:13:26.150
yet which means that maybe you

182
00:13:26.150 --> 00:13:30.005
will be the first
mathematician who will find,

183
00:13:30.005 --> 00:13:34.000
who will develop
some quantum algorithm which

184
00:13:34.000 --> 00:13:40.720
effectively solves some problems
from here, some NP-Hard problems.